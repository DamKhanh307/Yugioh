<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Yu-Gi-Oh! Mini</title>
<style>
:root {
    --bg-grass: #2d5a27;
    --board-mat: #28201a;
    --zone-bg: rgba(0, 0, 0, 0.3);
    --zone-border: rgba(255, 255, 255, 0.2);
    --zone-hover: rgba(255, 215, 0, 0.2);
    --accent: #ffd166;
    --text-color: #fff;
    --card-width: 70px;
    --card-height: 100px;
}
* { box-sizing: border-box; }
body {
    margin: 0;
    background: url("chisa.jpg");
    background-size: cover;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    overflow: hidden;     height: 100vh;
}

.hidden { display: none !important; }
.btn {
    background: linear-gradient(180deg, #3867d6, #2d98da);
    border: 1px solid #fff;
    padding: 8px 16px;
    color: white;
    cursor: pointer;
    border-radius: 4px;
    font-weight: bold;
    text-shadow: 1px 1px 2px black;
}
.btn:hover { filter: brightness(1.2); }
.btn.primary { background: linear-gradient(180deg, #f7b731, #eb3b5a); color: #fff; }

#screen-deck {
    max-width: 1200px; margin: 20px auto; background: rgba(0,0,0,0.8); padding: 20px; border-radius: 10px;
    height: 90vh; overflow-y: auto; display: none; flex-direction: column;
}
.deck-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 1px solid #555; padding-bottom: 10px;}
.search-bar { display: flex; gap: 10px; margin-bottom: 15px; }
.card-grid { display: flex; flex-wrap: wrap; gap: 10px; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 8px; min-height: 200px; }
.card-item { width: 80px; cursor: pointer; transition: transform 0.1s; }
.card-item:hover { transform: scale(1.1); z-index: 10; }
.card-item img { width: 100%; border-radius: 4px; }
.card-item .small { font-size: 10px; text-align: center; margin-top: 2px; overflow: hidden; white-space: nowrap; text-overflow: ellipsis;}

#screen-duel {
    display: flex;
    flex-direction: column;
    height: 100vh;
    position: relative;
}

.player-info {
    position: absolute;
    z-index: 100;
    padding: 10px 20px;
    background: rgba(0,0,0,0.8);
    border: 2px solid #555;
    border-radius: 8px;
    display: flex;
    align-items: center;
    gap: 15px;
    width: 320px;
    box-shadow: 0 4px 10px rgba(0,0,0,0.5);
}
.player-info img { width: 50px; height: 50px; border-radius: 50%; border: 2px solid #fff; }
.lp-bar { flex: 1; }
.lp-val { font-size: 24px; font-weight: bold; color: #ffeb3b; text-shadow: 0 0 5px #f00; font-family: 'Courier New', monospace; }
.player-name { font-size: 14px; text-transform: uppercase; color: #aaa; }

#info-opp { top: 20px; right: 20px; flex-direction: row-reverse; text-align: right; }
#info-player { bottom: 20px; left: 20px; }

.duel-field {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    perspective: 1200px;
}

.board-mat {
    width: 900px;
    height: 640px;
    /* background: var(--board-mat); */
    border: 8px solid #1a1410;
    border-radius: 4px;
    box-shadow: 0 20px 50px rgba(0,0,0,0.8);
    display: grid;
   grid-template-rows: 0.85fr 1.4fr 20px 1.4fr 0.85fr;     grid-template-columns: 100px repeat(5, 1fr) 100px;     gap: 8px;
    padding: 15px;
    position: relative;
    transform: rotateX(40deg) translateY(-20px)
}

.zone-slot {
    border: 2px dashed var(--zone-border);
    background: var(--zone-bg);
    border-radius: 4px;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    transition: 0.2s;
}
.zone-slot:hover { border-color: #fff; background: rgba(255,255,255,0.1); }
.zone-slot.active-zone { border-color: #ffff00; box-shadow: 0 0 10px #ffff00; }

.zone-label {
    position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%);
    font-size: 10px; color: rgba(255,255,255,0.2); text-align: center; pointer-events: none;
    font-weight: bold; text-transform: uppercase;
}

.card-in-zone {
  width: 100%;       
    height: 100%;
    object-fit: cover;
    background-position: center;
    border-radius: 3px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.5);
    cursor: pointer;
    position: relative;
}
.card-in-zone.facedown {
    background-image: url('https://upload.wikimedia.org/wikipedia/en/2/2b/Yugioh_Card_Back.jpg');
    background-size: contain;
    background-repeat: no-repeat;
}
.card-in-zone.defense { transform: rotate(-90deg); }

.opp-field-zone { grid-column: 7; grid-row: 1; } .opp-extra-zone { grid-column: 1; grid-row: 1; } 
.opp-deck-zone  { grid-column: 1; grid-row: 1; background: rgba(0,0,0,0.5); border: 2px solid #555; }
.opp-grave-zone { grid-column: 1; grid-row: 2; background: rgba(0,0,0,0.5); border: 2px solid #555; }


#oppST { display: contents; } #oppMZ { display: contents; }

#plMZ { display: contents; }
#plST { display: contents; }

.opp-st-0 { grid-column: 6; grid-row: 1; } .opp-st-1 { grid-column: 5; grid-row: 1; } .opp-st-2 { grid-column: 4; grid-row: 1; } .opp-st-3 { grid-column: 3; grid-row: 1; } .opp-st-4 { grid-column: 2; grid-row: 1; }
.opp-mz-0 { grid-column: 6; grid-row: 2; } .opp-mz-1 { grid-column: 5; grid-row: 2; } .opp-mz-2 { grid-column: 4; grid-row: 2; } .opp-mz-3 { grid-column: 3; grid-row: 2; } .opp-mz-4 { grid-column: 2; grid-row: 2; }

.player-mz-0 { grid-column: 2; grid-row: 4; } .player-mz-1 { grid-column: 3; grid-row: 4; } .player-mz-2 { grid-column: 4; grid-row: 4; } .player-mz-3 { grid-column: 5; grid-row: 4; } .player-mz-4 { grid-column: 6; grid-row: 4; }
.player-st-0 { grid-column: 2; grid-row: 5; } .player-st-1 { grid-column: 3; grid-row: 5; } .player-st-2 { grid-column: 4; grid-row: 5; } .player-st-3 { grid-column: 5; grid-row: 5; } .player-st-4 { grid-column: 6; grid-row: 5; }

.player-field-zone { grid-column: 1; grid-row: 4; border-color: #2e8b57; }
.player-extra-zone { grid-column: 1; grid-row: 5; border-color: #555; }
.player-grave-zone { grid-column: 7; grid-row: 4; border-color: #666; cursor: pointer;}
.player-deck-zone  { grid-column: 7; grid-row: 5; border-color: #8B4513; cursor: pointer;}

.opp-deck-slot  { grid-column: 1; grid-row: 1; border-color: #8B4513; }
.opp-grave-slot { grid-column: 1; grid-row: 2; border-color: #666; }
.opp-field-slot { grid-column: 7; grid-row: 2; border-color: #2e8b57; }
.opp-extra-slot { grid-column: 7; grid-row: 1; border-color: #555; }


.hand-container {
    position: absolute;
    left: 50%; transform: translateX(-50%);
    display: flex; gap: 5px;
    padding: 10px;
    z-index: 50;
}
#hand {     bottom: 0;
    align-items: flex-end;
}
.opp-hand {     top: 0;
    align-items: flex-start;
}
.hand-card {
    width: 90px; height: 130px;
    background: #111;
    border: 2px solid #fff;
    border-radius: 5px;
    box-shadow: -5px 0 10px rgba(0,0,0,0.5);
    transition: 0.2s;
    cursor: grab;
    position: relative;
}
.hand-card:hover { transform: translateY(-20px); z-index: 100; border-color: #ffff00; }
.hand-card img { width: 100%; height: 100%; object-fit: cover; border-radius: 4px; }
.opp-hand .hand-card {
    height: 100px; width: 70px;
    background-image: url('https://upload.wikimedia.org/wikipedia/en/2/2b/Yugioh_Card_Back.jpg');
    background-size: cover;
    border: 1px solid #555;
}

.phase-bar {
    position: absolute;
    top: 50%; right: 20px; transform: translateY(-50%);
    display: flex; flex-direction: column; gap: 5px;
}
.phase-step {
    padding: 5px 10px; background: rgba(0,0,0,0.6); color: #888; border: 1px solid #444; font-size: 12px; text-align: center;
}
.phase-step.active { background: #ffeb3b; color: #000; font-weight: bold; box-shadow: 0 0 10px #ffeb3b; }

.controls-area {
    position: absolute; bottom: 20px; right: 20px;
    display: flex; flex-direction: column; gap: 10px; z-index: 101;
}

.log-box {
    position: absolute; top: 120px; left: 20px;
    width: 250px; height: 150px;
    background: rgba(0,0,0,0.7);
    border: 1px solid #555;
    color: #ccc; font-size: 12px;
    padding: 5px; overflow-y: auto;
    pointer-events: none; }

@keyframes draw { from { transform: translateY(-100px); opacity:0; } to { transform: translateY(0); opacity:1; } }
.hand-card { animation: draw 0.3s ease-out; }



/* --- MOBILE LANDSCAPE OPTIMIZATION --- */
@media only screen and (max-height: 500px) and (orientation: landscape) {
    
    /* 1. Tinh chỉnh khung bao quanh để không bị cuộn trang */
    #screen-duel {
        overflow: hidden;
        height: 100vh;
        width: 100vw;
    }

    /* 2. Biến đổi bàn cờ: Bỏ 3D, thu nhỏ lại và căn giữa */
    .duel-field {
        align-items: flex-start; /* Đẩy bàn cờ lên phía trên */
        padding-top: 5px;
        height: 100%;
    }
    .board-mat {
        /* Quan trọng: Thu nhỏ bàn cờ xuống 55% và bỏ xoay 3D */
        transform: scale(0.55) rotateX(0deg) translateY(0); 
        transform-origin: top center; /* Thu nhỏ từ cạnh trên */
        margin-bottom: -300px; /* Kéo các phần tử bên dưới lên vì bàn cờ đã thu nhỏ */
        box-shadow: none; /* Bỏ bóng cho nhẹ máy */
    }

    /* 3. Thu gọn thông tin người chơi (LP, Avatar) */
    .player-info {
        width: 180px;
        padding: 4px 8px;
        gap: 8px;
        background: rgba(0,0,0,0.9);
        border: 1px solid #444;
    }
    .player-info img { width: 35px; height: 35px; border-width: 1px; }
    .player-name { font-size: 10px; display: none; /* Ẩn tên để tiết kiệm chỗ */ }
    .lp-val { font-size: 18px; }

    /* Đặt Đối thủ ở góc TRÁI TRÊN */
    #info-opp {
        top: 5px; left: 5px; right: auto;
        flex-direction: row; /* Xếp ngang bình thường */
        z-index: 200;
    }
    
    /* Đặt Người chơi ở góc TRÁI DƯỚI */
    #info-player {
        bottom: 5px; left: 5px; top: auto;
        z-index: 200;
    }

    /* 4. Xử lý bộ bài trên tay (Hand) */
    .hand-container#hand {
        bottom: 0;
        left: auto; 
        right: 0; /* Dồn về bên phải */
        transform: none; /* Bỏ căn giữa cũ */
        width: 65%; /* Chỉ chiếm 65% màn hình bên phải */
        justify-content: flex-end; /* Căn bài sang phải */
        padding-right: 10px;
        z-index: 300;
    }
    .hand-card {
        width: 55px; height: 80px; /* Thu nhỏ lá bài trên tay */
    }
    /* Khi hover thì phóng to lên để xem */
    .hand-card:hover {
        transform: translateY(-50px) scale(1.5);
        z-index: 999;
    }

    /* 5. Bộ điều khiển (Nút bấm) */
    .controls-area {
        top: 5px; right: 5px; bottom: auto; /* Đưa lên góc PHẢI TRÊN */
        flex-direction: row; /* Xếp nút nằm ngang */
        transform: scale(0.8); /* Thu nhỏ nút một chút */
        transform-origin: top right;
    }
    
    /* 6. Ẩn các thành phần không quan trọng để thoáng màn hình */
    .phase-bar { display: none; } /* Ẩn thanh Phase */
    .log-box { display: none; } /* Ẩn Log chat */
    #turnBadge { font-size: 10px; }

    /* 7. Chỉnh lại Hand đối thủ (chỉ để trang trí) */
    .opp-hand {
        top: -40px; /* Giấu bớt lên trên */
        transform: scale(0.6);
    }
}

/* Nút phủ toàn màn hình khi xoay ngang */
#fullscreen-request {
    display: none; /* Mặc định ẩn */
}

/* @media only screen and (max-height: 500px) and (orientation: landscape) { */
    /* Chỉ hiện khi xoay ngang trên mobile */
    #fullscreen-request {
        display: flex;
        position: fixed;
        top: 0; left: 0;
        width: 100vw; height: 100vh;
        background: url("bg.jpg");
        background-size: cover;
        z-index: 9999;
        align-items: center;
        justify-content: center;
        flex-direction: column;
        color: #fff;
        text-align: center;
        cursor: pointer;
    }
    .splash_enter {
        padding: 15px 30px;
        font-size: 20px;
        background: rgba(0,0,0,0.6);
        border: 2px solid #fff;
        border-radius: 8px;
        color: #ffd166;
        font-weight: bold;
        cursor: pointer;
        box-shadow: 0 0 10px #fff;
    }
    #fullscreen-request h3 { margin: 0 0 10px 0; color: #ffd166; font-size: 24px; }
    #fullscreen-request p { margin: 0; color: #ccc; font-size: 14px; }
    
    /* Khi đã fullscreen rồi thì ẩn lớp phủ này đi */
    :fullscreen #fullscreen-request { display: none !important; }
    :-webkit-full-screen #fullscreen-request { display: none !important; }
/* } */

.intro {
    position: fixed;
    top: 0; left: 0;
    width: 100vw; height: 100vh;
    background: #000;
    z-index: 10000; /* Đè lên tất cả */
    display: none; /* Mặc định ẩn */
    align-items: center;
    justify-content: center;
}
.intro video {
    width: 100%;
    height: 100%;
    object-fit: contain; /* Giữ tỷ lệ video */
}

</style>
</head>
<body>
<div id="fullscreen-request">
    <button class="splash_enter" onclick="playIntro()">Link Started</button>
</div>

<div class="intro" id="intro-layer">
    <video id="intro-video" src="intro.mp4"></video> 
</div>
<div id="screen-deck">
    <div class="deck-header">
        <h2 style="color:#ffd166; margin:0">Yu-Gi-Oh! Deck Build</h2>
        <div style="text-align:right">
            <span class="small">Deck: <span id="deckCount">0</span>/20</span>
            <button id="btnStart" class="btn primary" style="margin-left:10px">DUEL START</button>
        </div>
    </div>
    
    <div style="display:flex; gap:20px; flex:1">
        <div style="flex:2; display:flex; flex-direction:column">
            <div class="search-bar">
                <input id="searchInput" placeholder="Tìm tên bài (VD: Dark Magician)..." style="flex:1; padding:10px; background:#222; border:1px solid #555; color:#fff; border-radius:4px">
                <button id="btnSearch" class="btn">Tìm</button>
                <button id="btnRandom" class="btn">Random</button>
            </div>
            <div id="cardGrid" class="card-grid"></div>
        </div>
        
        <div style="flex:1; background:rgba(0,0,0,0.3); padding:10px; border-radius:8px; display:flex; flex-direction:column">
            <div style="display:flex; justify-content:space-between; margin-bottom:10px">
                <strong>Your Deck</strong>
                <button id="clearDeck" class="btn" style="padding:4px 8px; font-size:12px; background:#c0392b">Clear</button>
            </div>
            <div id="selectedDeck" class="card-grid" style="flex:1; align-content:flex-start"></div>
        </div>
    </div>
</div>

<div id="screen-duel" class="hidden">
    
    <div class="player-info" id="info-opp">
        <img src="https://i.pinimg.com/736x/2f/15/22/2f1522f203879a61ce592398452488e0.jpg" alt="Kaiba"> <div class="lp-bar">
            <div class="player-name">Kaiba Corp AI</div>
            <div class="lp-val" id="oppLP">8000</div>
        </div>
    </div>

    <div class="hand-container opp-hand" id="oppHandVisual">
        </div>

    <div class="duel-field">
        <div class="board-mat">
            
            <div class="zone-slot opp-deck-slot"><div class="zone-label">DECK</div><span id="oppDeckCnt" style="position:absolute; bottom:2px; right:2px; font-size:18px; font-weight:bold; color:#fff">20</span></div>
            <div class="zone-slot opp-grave-slot" id="oppGraveBox"><div class="zone-label">GY</div></div>
            
            <div id="oppST" style="display:contents"></div>
            <div id="oppMZ" style="display:contents"></div>

            <div class="zone-slot opp-field-slot"><div class="zone-label">FIELD</div></div>
            <div class="zone-slot opp-extra-slot"><div class="zone-label">EXTRA</div></div>

            <div class="zone-slot player-field-zone"><div class="zone-label">FIELD</div></div>
            <div class="zone-slot player-extra-zone"><div class="zone-label">EXTRA</div></div>

            <div id="plMZ" style="display:contents"></div>
            <div id="plST" style="display:contents"></div>

            <div class="zone-slot player-grave-zone" id="plGraveBox">
                <div class="zone-label">GY</div>
                <div id="plGraveTop" style="z-index:1; width:100%; height:100%; display:flex; align-items:center; justify-content:center; font-size:10px;"></div>
            </div>
            <div class="zone-slot player-deck-zone">
                <div class="zone-label">DECK</div>
                <div style="width:100%; height:100%; background:url('https://upload.wikimedia.org/wikipedia/en/2/2b/Yugioh_Card_Back.jpg'); background-size:cover; border-radius:3px"></div>
                <span id="plDeckCnt" style="position:absolute; bottom:5px; right:5px; font-weight:bold; font-size:18px; text-shadow:1px 1px 2px #000">20</span>
            </div>

        </div>
    </div>

    <div class="player-info" id="info-player">
        <img src="https://i.pinimg.com/736x/89/c6/39/89c6396e9444b0253457a41285375543.jpg" alt="Yugi">
        <div class="lp-bar">
            <div class="player-name">Duelist (You)</div>
            <div class="lp-val" id="plLP">8000</div>
        </div>
        <div style="color:#aaa; font-size:12px">Turn: <span id="turnBadge" style="color:#fff; font-weight:bold">YOURS</span></div>
    </div>

    <div class="phase-bar">
        <div class="phase-step">DRAW</div>
        <div class="phase-step">STANDBY</div>
        <div class="phase-step active" id="phaseName">MAIN</div>
        <div class="phase-step">BATTLE</div>
        <div class="phase-step">END</div>
    </div>

    <div class="log-box" id="log">
        <div>-- Duel Log --</div>
    </div>

    <div class="controls-area">
        <div style="background:rgba(0,0,0,0.8); padding:10px; border-radius:8px; color:#fff; margin-bottom:10px">
             Selected: <span id="selectedInfo" style="color:#ffd166">None</span>
        </div>
        <button id="btnDraw" class="btn">Draw Card</button>
        <button id="btnToBattle" class="btn" style="background: linear-gradient(180deg, #c23616, #c0392b);">Battle Phase</button>
        <button id="btnEnd" class="btn primary">End Turn</button>
    </div>

    <div class="hand-container" id="hand"></div>

</div>



<script>
const API_BASE = 'https://db.ygoprodeck.com/api/v7/cardinfo.php?fname=';
const MAX_DECK = 20;

let hasEnteredGame = false;

function id(x){return document.getElementById(x)}
function el(tag,cls){const d=document.createElement(tag); if(cls) d.className=cls; return d}
function log(msg){ 
    const now = new Date().toLocaleTimeString('vi-VN',{hour12:false}); 
    const d = document.createElement('div');
    d.innerHTML = `<span style="color:#888">[${now}]</span> ${msg}`;
    const box = id('log');
    box.insertBefore(d, box.childNodes[1]);
}

let chosenDeck = [];
let player = { lp:8000, deck:[], hand:[], field:[null,null,null,null,null], st:[null,null,null,null,null], grave:[] }
let opp = { lp:8000, deck:[], hand:[], field:[null,null,null,null,null], st:[null,null,null,null,null], grave:[] }
let state = { turn:'player', phase:'MAIN', selected:null, started:false, firstTurn:true, hasDrawn:false,normalSummonUsed: false}


const cardGrid = id('cardGrid'), selectedDeckEl = id('selectedDeck'), deckCountEl = id('deckCount')

id('btnSearch').onclick = async () => {
  const q = id('searchInput').value.trim()
  if(!q) return showAlertAndResumeFullscreen('Nhập tên bài để tìm!')
  await searchAndShow(q)
}
id('btnRandom').onclick = ()=> {
  const samples = [
    {id:'c1',name:'Dark Magician',atk:2500,def:2100,image:'https://images.ygoprodeck.com/images/cards/46986414.jpg'},
    {id:'c2',name:'Blue-Eyes White Dragon',atk:3000,def:2500,image:'https://images.ygoprodeck.com/images/cards/89631139.jpg'},
    {id:'c3',name:'Mirror Force',image:'https://images.ygoprodeck.com/images/cards/44095762.jpg'},
    {id:'c4',name:'Pot of Greed',image:'https://images.ygoprodeck.com/images/cards/55144522.jpg'},
    {id:'c5',name:'Summoned Skull',atk:2500,def:1200,image:'https://images.ygoprodeck.com/images/cards/70781052.jpg'}
  ]
  renderCardResults(samples)
}
id('clearDeck').onclick = ()=> { chosenDeck=[]; renderSelectedDeck(); }
id('btnStart').onclick = ()=> {
  if(chosenDeck.length < 5) return showAlertAndResumeFullscreen('Bộ bài cần ít nhất 5 lá!')
  startDuel()
}

async function searchAndShow(name){
  cardGrid.innerHTML = '<div style="color:#fff">Đang tìm...</div>'
  try{
    const res = await fetch(API_BASE + encodeURIComponent(name))
    const j = await res.json()
    if(!j.data || j.data.length===0) { cardGrid.innerHTML = '<div>Không tìm thấy</div>'; return }
    const results = j.data.slice(0,10).map(c=>({
      id: c.id, name: c.name, atk: c.atk, def: c.def,
      image: c.card_images[0].image_url
    }))
    renderCardResults(results)
  }catch(e){ cardGrid.innerHTML = '<div class="alert">Lỗi API (thử Random)</div>' }
}

function renderCardResults(arr){
  cardGrid.innerHTML = ''
  arr.forEach(c=>{
    const d = el('div','card-item'); 
    d.innerHTML = `<img src="${c.image}"><div class="small">${c.name}</div>`
    d.onclick = ()=>{
       if(chosenDeck.length>=MAX_DECK) return showAlertAndResumeFullscreen('Deck đầy!')
       chosenDeck.push({...c, uid: Math.random().toString(36).substr(2,9)})
       renderSelectedDeck()
    }
    cardGrid.appendChild(d)
  })
}

function renderSelectedDeck(){
  selectedDeckEl.innerHTML = ''
  chosenDeck.forEach((c,i)=>{
    const d = el('div','card-item'); d.innerHTML=`<img src="${c.image}">`;
    d.onclick = ()=>{ chosenDeck.splice(i,1); renderSelectedDeck() }
    selectedDeckEl.appendChild(d)
  })
  deckCountEl.textContent = chosenDeck.length
}

function startDuel(){
  // Clone deck
  player.deck = chosenDeck.map(c=>({...c})); shuffle(player.deck)
  opp.deck = chosenDeck.map(c=>({...c})); shuffle(opp.deck) // Opp dùng chung deck cho test
  
  // Reset state
  player.hand=[]; player.field=[null,null,null,null,null]; player.st=[null,null,null,null,null]; player.grave=[]
  opp.hand=[]; opp.field=[null,null,null,null,null]; opp.st=[null,null,null,null,null]; opp.grave=[]
  player.lp=8000; opp.lp=8000
  state.turn='player';
  state.phase='MAIN'; 
  state.started=true;
  state.firstTurn = true;
  state.hasDrawn = true;

  id('screen-deck').classList.add('hidden')
  id('screen-duel').classList.remove('hidden')
  
  // Draw starting hands
  for(let i=0;i<5;i++){ drawCard('player',false); drawCard('opp',false) }
  log('DUEL START! Your Turn.')
  renderAll()
}

function shuffle(a){ for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]]}}
function drawCard(who, logMsg=true){
  const p = who==='player'?player:opp;
  if(p.deck.length===0) return;
  p.hand.push(p.deck.pop());
  if(logMsg) log(`${who==='player'?'Bạn':'Opponent'} rút bài.`)
  renderAll()
}

function renderAll(){
  id('plLP').textContent = player.lp; id('oppLP').textContent = opp.lp
  if (checkGameEnd()) return;
  id('plDeckCnt').textContent = player.deck.length; id('oppDeckCnt').textContent = opp.deck.length
  id('turnBadge').textContent = state.turn==='player'?'YOUR TURN':'OPP TURN'
  id('phaseName').textContent = state.phase
  id('selectedInfo').textContent = state.selected ? state.selected.name : 'None'

  // Render Zones (Truyền thêm class Grid tương ứng)
  renderZoneGroup('plMZ', player.field, 'player', 'mz')
  renderZoneGroup('plST', player.st, 'player', 'st')
  renderZoneGroup('oppMZ', opp.field, 'opp', 'mz')
  renderZoneGroup('oppST', opp.st, 'opp', 'st')

  // Graves
  const plGraveImg = player.grave.length ? `<img src="${player.grave[player.grave.length-1].image}" style="width:100%;height:100%;object-fit:cover;border-radius:3px;opacity:0.8">` : '';
  id('plGraveTop').innerHTML = plGraveImg;

  const oppGraveImg = opp.grave.length ? `<img src="${opp.grave[opp.grave.length-1].image}" style="width:100%;height:100%;object-fit:cover;border-radius:3px;opacity:0.8">` : '';
  id('oppGraveBox').innerHTML = `<div class="zone-label">GY</div>` + oppGraveImg;

  // Hand Player
  const h = id('hand'); h.innerHTML='';
  player.hand.forEach(c=>{
    const d = el('div','hand-card'); 
    d.innerHTML=`<img src="${c.image}">`;
    d.draggable=true;
    d.ondragstart = (e)=> e.dataTransfer.setData('json', JSON.stringify({uid:c.uid, src:'hand'}))
    // Click to summon (simple mode)
    d.onclick = ()=>{
         // Tự động tìm ô trống
         if(state.turn!=='player' || state.phase!=='MAIN') return log('Không thể làm lúc này!')
         if(c.atk !== undefined) playCard(c, 'mz'); else playCard(c, 'st');
    }
    h.appendChild(d)
  })

  // Hand Opponent (Visual)
  const oh = id('oppHandVisual'); oh.innerHTML='';
  opp.hand.forEach(()=> oh.appendChild(el('div','hand-card')))


  // Cập nhật tên nút Battle theo phase
    if (state.phase === 'MAIN') {
        id('btnToBattle').textContent = "Battle Phase";
    } 
    else if (state.phase === 'BATTLE') {
        id('btnToBattle').textContent = "Main Phase 2";
    } 
    else if (state.phase === 'MAIN2') {
        id('btnToBattle').textContent = "Main Phase 2";
    }

}

function renderZoneGroup(domId, arr, owner, type){
  const div = id(domId); div.innerHTML='';
  arr.forEach((c, idx)=>{
    // Tạo slot với class grid tương ứng (VD: player-mz-0)
    // Cần đảo ngược thứ tự hiển thị cho đúng grid nếu cần, nhưng grid placement css đã lo rồi.
    const slot = el('div', `zone-slot ${owner}-${type}-${idx}`);
    slot.ondragover = (e)=>e.preventDefault();
    slot.ondrop = (e)=> handleDrop(e, idx, type);
    slot.onclick = ()=> handleZoneClick(owner, type, idx);

    if(state.selected && state.selected.owner===owner && state.selected.idx===idx && state.selected.type===type){
        slot.classList.add('active-zone');
    }

    if(c){
        const cardDiv = el('div', 'card-in-zone');
        if(c.facedown) cardDiv.classList.add('facedown');
        else {
          cardDiv.style.backgroundImage = `url('${c.image}')`;
          cardDiv.style.backgroundSize = `contain`;
          cardDiv.style.backgroundRepeat = `no-repeat`;

        }
        
        // Attack/Def display
        if(c.atk!==undefined && !c.facedown){
            const stat = el('div'); 
            stat.style.cssText='position:absolute;bottom:0;width:100%;background:rgba(0,0,0,0.7);color:#fff;font-size:9px;text-align:center';
            stat.innerHTML = `ATK/${c.atk} DEF/${c.def}`;
            cardDiv.appendChild(stat);
        }
        slot.appendChild(cardDiv);
    }
    div.appendChild(slot);
  })
}

    function handleDrop(e, idx, type){
    if(state.turn!=='player' || state.phase!=='MAIN') return
    const data = JSON.parse(e.dataTransfer.getData('json'))
    if(data.src==='hand'){
        const cardIdx = player.hand.findIndex(x=>x.uid===data.uid);
        if(cardIdx<0) return;
        const card = player.hand[cardIdx];
        
        if(type==='mz' && !card.atk) return log('Spell/Trap không thể đặt vào ô quái!');
        if(type==='st' && card.atk) return log('Quái thú không thể đặt vào ô phép!');

        player.field[idx] && type==='mz' ? log('Ô đã có bài') : null; // Simple check
        if(type==='mz' && !player.field[idx]) {

            if (state.normalSummonUsed) {
                log("Bạn chỉ được triệu hồi 1 lần mỗi lượt!");
                return;
            }

            player.field[idx] = card; 
            player.hand.splice(cardIdx,1);
            state.normalSummonUsed = true;
            log(`Triệu hồi ${card.name}`);
        }

        if(type==='st' && !player.st[idx]) {
            player.st[idx] = {...card, facedown:true}; player.hand.splice(cardIdx,1);
            log(`Set ${card.name}`);
        }
        renderAll();
    }
    }

function playCard(card, type){
    // Chỉ được thao tác trong Main Phase hoặc Main Phase 2
    if (state.turn !== 'player' || (state.phase !== 'MAIN' && state.phase !== 'MAIN2')) {
        log("Không thể thực hiện hành động này ở phase hiện tại!");
        return;
    }

    // Lấy zone
    const arr = type === 'mz' ? player.field : player.st;
    const emptyIdx = arr.findIndex(x => x === null);
    if (emptyIdx === -1) return log('Hết chỗ trống!');

    // -------------------------
    // 1) Giới hạn Normal Summon
    // -------------------------
    if (type === 'mz') {
        // Quái úp xuống cũng tính là summon
        if (state.normalSummonUsed) {
            log("Bạn chỉ được triệu hồi 1 quái mỗi lượt!");
            return;
        }
    }

    // Xóa khỏi hand
    const hIdx = player.hand.indexOf(card);
    if (hIdx > -1) player.hand.splice(hIdx, 1);

    // -------------------------
    // 2) Triệu hồi quái / Set spell-trap
    // -------------------------
    if (type === 'st') {
        arr[emptyIdx] = { ...card, facedown: true };
        log(`Set ${card.name}`);
    } else {
        // Triệu hồi quái
        arr[emptyIdx] = card;
        state.normalSummonUsed = true;   // Đánh dấu đã summon
        log(`Triệu hồi ${card.name}`);
    }

    renderAll();
}

function showConfirmAndResumeFullscreen(message) {
    const result = confirm(message);
    if (typeof hasEnteredGame !== 'undefined' && hasEnteredGame) {
        setTimeout(toggleFullScreen, 0); 
    }
    return result; 
}
function handleZoneClick(owner, type, idx){
    const arr = owner==='player' ? (type==='mz'?player.field:player.st) : (type==='mz'?opp.field:opp.st);
    const card = arr[idx];

    // 1) Nếu click bài của player => chọn / kích hoạt
    if(owner==='player' && card){
        if(type==='st' && card.facedown){
            if(showConfirmAndResumeFullscreen(`Kích hoạt ${card.name}?`)){
                delete card.facedown;
                log(`Kích hoạt Spell: ${card.name}`);
                if(card.name === 'Raigeki'){
                    opp.field = [null,null,null,null,null];
                    log('Raigeki hủy diệt quái đối thủ!');
                }
                // Sau khi dùng thì xuống mộ
                setTimeout(()=>{
                    player.grave.push(card);
                    arr[idx] = null;
                    renderAll();
                }, 1000);
            }
        } else {
            state.selected = {owner, type, idx, name: card.name, atk: card.atk};
            log(`Chọn: ${card.name}`);
            renderAll();
        }
        return;
    }

    // 2) Nếu click lên quái của đối thủ trong Battle và đã chọn quái của player -> thực hiện tấn công
    if(owner==='opp' && type==='mz' && state.selected && state.selected.owner==='player' && state.turn==='player' && state.phase==='BATTLE'){
        // Chặn lượt đầu được tấn công
        if (state.firstTurn) {
            log("Lượt đầu không được tấn công!");
            state.selected = null;
            renderAll();
            return;
        }

        // Lấy reference quái tấn công và bị tấn công
        const myMon = player.field[state.selected.idx];
        const oppMon = opp.field[idx];

        if(!myMon){
            // nếu vô tình không có quái (bị hủy trước đó) thì bỏ chọn
            state.selected = null;
            renderAll();
            return;
        }

        log(`${myMon.name} tấn công ${oppMon ? oppMon.name : 'trực tiếp'}!`);

        // So sánh ATK đơn giản
        if(oppMon){
            const atkA = myMon.atk || 0;
            const atkB = oppMon.atk || 0;
            if(atkA > atkB){
                const dmg = atkA - atkB;
                opp.lp -= dmg;
                opp.grave.push(oppMon);
                opp.field[idx] = null;
                log(`Thắng chiến đấu! Opponent -${dmg} LP`);
            } else if(atkA < atkB){
                const dmg = atkB - atkA;
                player.lp -= dmg;
                player.grave.push(myMon);
                player.field[state.selected.idx] = null;
                log(`Thua chiến đấu! Bạn -${dmg} LP`);
            } else {
                // hòa
                opp.grave.push(oppMon);
                opp.field[idx] = null;
                player.grave.push(myMon);
                player.field[state.selected.idx] = null;
                log(`Hòa! Cả 2 cùng chết.`);
            }
        } else {
            // direct attack
            const dmg = myMon.atk || 0;
            opp.lp -= dmg;
            log(`Tấn công trực tiếp! -${dmg} LP`);
        }

        state.selected = null;
        renderAll();
        return;
    }

    // 3) Nếu click vào ô khác (ví dụ click ô trống của opp hoặc click vào vùng không liên quan)
    // => chỉ render lại hoặc bỏ chọn
    if(state.selected){
        state.selected = null;
        renderAll();
    }
}

// Attack Direct (Click avatar đối thủ)
id('info-opp').onclick = ()=>{
    if(state.turn==='player' && state.phase==='BATTLE' && state.selected && state.selected.type==='mz'){
        // Check if opp has monster
        if(opp.field.some(x=>x!==null)) return log('Đối thủ còn quái, không thể đánh trực tiếp!');
        const myMon = player.field[state.selected.idx];
        opp.lp -= (myMon.atk||0);
        log(`${myMon.name} tấn công trực tiếp! -${myMon.atk} LP`);
        state.selected = null;
        renderAll();
    }
}

id('btnDraw').onclick = () => {
    if (state.turn !== 'player') return log('Chỉ rút khi là lượt bạn.');
    if (state.hasDrawn) return log('Bạn đã rút trong lượt này rồi!');
    drawCard('player');
    state.hasDrawn = true;
};

id('btnToBattle').onclick = () => {
    // MAIN → (Battle) hoặc skip nếu turn đầu
    if (state.phase === 'MAIN') {

        // Lượt đầu: bỏ qua battle, sang MAIN2
        if (state.turn === 'player' && state.firstTurn) {
            state.phase = 'MAIN2';
            id('btnToBattle').textContent = "Main Phase 2";
            log("Lượt đầu không battle — chuyển thẳng Main Phase 2");
        } else {
            state.phase = 'BATTLE';
            id('btnToBattle').textContent = "Main Phase 2";
            log("Battle Phase!");
        }
    }

    // BATTLE → MAIN2
    else if (state.phase === 'BATTLE') {
        state.phase = 'MAIN2';
        id('btnToBattle').textContent = "Main Phase 2";
        log("Main Phase 2!");
    }

    // MAIN2 → button disabled (không quay lại battle)
    else if (state.phase === 'MAIN2') {
        log("Đang ở Main Phase 2 rồi, không quay lại Battle được.");
    }

    renderAll();
};



id('btnEnd').onclick = () => { 
    if (state.phase !== 'MAIN2') {
        log("Phải qua Main Phase 2 mới End được!");
        return;
    }

    // Kết thúc lượt player -> chuyển sang lượt đối thủ
    state.turn = 'opp'; 
    state.phase = 'DRAW'; 
    // Sau khi player chính thức end turn thì lượt đầu đã qua
    state.firstTurn = false; 
    // Reset hasDrawn cho lượt tới (opp sẽ tự rút đầu lượt trong oppAI)
    state.hasDrawn = false;
    state.normalSummonUsed = false;

    renderAll(); 
    log('Kết thúc lượt.');

    setTimeout(oppAI, 1000);
};


function oppAI(){
    drawCard('opp');
    // Summon random
    const monIdx = opp.hand.findIndex(c=>c.atk!==undefined);
    if(monIdx>-1){
        const empty = opp.field.findIndex(x=>x===null);
        if(empty>-1){
            opp.field[empty] = opp.hand.splice(monIdx,1)[0];
            log(`Opponent summon ${opp.field[empty].name}`);
        }
    }
    renderAll();
    setTimeout(()=>{
    state.turn = 'player';
    state.phase = 'MAIN';
    state.normalSummonUsed = false;

    // Khi bắt đầu lượt player sau opp, auto draw 1 lá nếu chưa rút
    if (!state.hasDrawn) {
        drawCard('player');
        state.hasDrawn = true;
    }
    log('Lượt của bạn.');
    renderAll();
}, 1500);

}

function checkGameEnd() {
    // Nếu game chưa bắt đầu hoặc đã kết thúc thì bỏ qua
    if (!state.started) return false;

    // Kiểm tra LP
    if (player.lp <= 0 || opp.lp <= 0) {
        state.started = false; // Dừng trạng thái game

        // Cập nhật giao diện lần cuối để hiển thị số 0 hoặc âm
        id('plLP').textContent = player.lp;
        id('oppLP').textContent = opp.lp;

        // Dùng setTimeout để giao diện kịp hiển thị điểm số trước khi hiện thông báo
        setTimeout(() => {
            if (player.lp <= 0 && opp.lp <= 0) {
                showAlertAndResumeFullscreen("KẾT QUẢ: HÒA (DRAW)!");
            } else if (player.lp <= 0) {
                showAlertAndResumeFullscreen("KẾT QUẢ: BẠN ĐÃ THUA (DEFEAT)!");
            } else {
                showAlertAndResumeFullscreen("KẾT QUẢ: BẠN ĐÃ THẮNG (VICTORY)!");
            }
            // Tải lại trang để chơi mới
            location.reload();
        }, 500);
        return true;
    }
    return false;
}


/* --- FULLSCREEN LOGIC --- */
function toggleFullScreen() {
    var doc = window.document;
    var docEl = doc.documentElement;

    var requestFullScreen = docEl.requestFullscreen || docEl.mozRequestFullScreen || docEl.webkitRequestFullScreen || docEl.msRequestFullscreen;
    var cancelFullScreen = doc.exitFullscreen || doc.mozCancelFullScreen || doc.webkitExitFullscreen || doc.msExitFullscreen;

    if(!doc.fullscreenElement && !doc.mozFullScreenElement && !doc.webkitFullscreenElement && !doc.msFullscreenElement) {
        // Nếu chưa fullscreen thì bật lên
        if(requestFullScreen) requestFullScreen.call(docEl);
        // Sau khi bật thì ẩn cái overlay đi
        id('fullscreen-request').style.display = 'none';
    } else {
        // Nếu đang fullscreen thì tắt (nếu cần)
        if(cancelFullScreen) cancelFullScreen.call(doc);
    }
}

// Lắng nghe sự kiện thay đổi kích thước/xoay để hiện lại overlay nếu bị thoát fullscreen
window.addEventListener('resize', function(){

    if (hasEnteredGame) {
        return; 
    }
    // Kiểm tra nếu đang xoay ngang và chưa fullscreen
    if(window.innerHeight < 500 && window.innerWidth > window.innerHeight) {
        if(!document.fullscreenElement && !document.webkitFullscreenElement) {
             id('fullscreen-request').style.display = 'flex';
        } else {
             id('fullscreen-request').style.display = 'none';
        }
    } else {
        // Màn hình dọc thì ẩn luôn
        id('fullscreen-request').style.display = 'none';
    }
});
function playIntro() {
    // 1. Kích hoạt Fullscreen (Logic cũ của bạn)
    toggleFullScreen();

    // 2. Ẩn nút Link Started
    document.getElementById('fullscreen-request').style.display = 'none';

    // 3. Hiện lớp Video
    const introLayer = document.getElementById('intro-layer');
    const vid = document.getElementById('intro-video');
    
    introLayer.style.display = 'flex';

    // 4. Bắt đầu phát video
    vid.play().catch(e => {
        console.log("Trình duyệt chặn tự phát video:", e);
        // Nếu lỗi (do policy trình duyệt), ta cứ cho vào game luôn
        enterDeckScreen();
    });

    // 5. Khi video kết thúc -> Vào màn hình chọn bài
    vid.onended = function() {
        enterDeckScreen();
    };
    
    // (Tùy chọn) Cho phép click vào video để bỏ qua (Skip)
    introLayer.onclick = function() {
        vid.pause();
        enterDeckScreen();
    }
}

function enterDeckScreen() {
    hasEnteredGame = true;
    // Ẩn video
    document.getElementById('intro-layer').style.display = 'none';
    
    // Hiện màn hình Deck (chuyển sang flex như style gốc)
    const deckScreen = document.getElementById('screen-deck');
    deckScreen.style.display = 'flex';
    deckScreen.classList.remove('hidden');
}

function showAlertAndResumeFullscreen(message) {
    alert(message);
    if (typeof hasEnteredGame !== 'undefined' && hasEnteredGame) {
        setTimeout(toggleFullScreen, 0);
    }
}
</script>
</body>
</html>
